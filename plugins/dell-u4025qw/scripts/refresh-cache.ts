#!/usr/bin/env bun

/**
 * PreToolUse hook: Refresh community intelligence cache for the Dell U4025QW skill.
 *
 * Self-contained - uses only Bun built-in APIs.
 * Runs once per session (via `once: true` in SKILL.md frontmatter).
 *
 * - Reads cache/last-updated.json to check staleness
 * - If next_update_after is in the future, exits 0 (no-op)
 * - If stale or missing, runs @side-quest/last-30-days for each topic
 * - Writes results to cache/community-intel.md
 * - Updates cache/last-updated.json with new 30-day cycle
 *
 * Exit 0 = success (always non-blocking).
 */

import { existsSync, readFileSync } from 'node:fs'
import { join } from 'node:path'

const TOPICS = [
	'Dell U4025QW firmware update issues',
	'Dell U4025QW macOS BetterDisplay Lunar issues',
]

const REFRESH_INTERVAL_DAYS = 30
const QUERY_TIMEOUT_MS = 60_000

interface CacheMetadata {
	last_updated: string
	topics_researched: string[]
	next_update_after: string
}

interface Last30DaysResult {
	topic: string
	summary?: string
	findings?: string[]
	sources?: Array<{ title: string; url: string }>
}

/** Resolve the skill cache directory from CLAUDE_PLUGIN_ROOT. */
function getCacheDir(): string {
	const pluginRoot = process.env.CLAUDE_PLUGIN_ROOT
	if (!pluginRoot) {
		throw new Error('CLAUDE_PLUGIN_ROOT environment variable is not set')
	}
	return join(pluginRoot, 'skills', 'dell-u4025qw', 'cache')
}

/** Check whether the cache is still fresh. */
function isCacheFresh(cacheDir: string): boolean {
	const metadataPath = join(cacheDir, 'last-updated.json')
	if (!existsSync(metadataPath)) return false

	try {
		const text = readFileSync(metadataPath, 'utf-8')
		const metadata: CacheMetadata = JSON.parse(text)
		const nextUpdate = new Date(metadata.next_update_after)
		return nextUpdate.getTime() > Date.now()
	} catch {
		return false
	}
}

/** Run a single last-30-days query and return parsed JSON or null. */
async function runQuery(topic: string): Promise<Last30DaysResult | null> {
	const proc = Bun.spawn(
		[
			'bunx',
			'--bun',
			'@side-quest/last-30-days',
			topic,
			'--emit=json',
			'--quick',
		],
		{
			stdout: 'pipe',
			stderr: 'pipe',
			env: { ...process.env, NO_COLOR: '1' },
		},
	)

	const exitCode = await Promise.race([
		proc.exited,
		new Promise<null>((resolve) =>
			setTimeout(() => {
				proc.kill()
				resolve(null)
			}, QUERY_TIMEOUT_MS),
		),
	])

	if (exitCode === null) {
		console.error(
			JSON.stringify({
				tool: 'refresh-cache',
				topic,
				status: 'timeout',
				message: `Query timed out after ${QUERY_TIMEOUT_MS}ms`,
			}),
		)
		return null
	}

	const stdout = await new Response(proc.stdout).text()

	if (exitCode !== 0) {
		const stderr = await new Response(proc.stderr).text()
		console.error(
			JSON.stringify({
				tool: 'refresh-cache',
				topic,
				status: 'error',
				stderr: stderr.slice(0, 200),
			}),
		)
		return null
	}

	try {
		return JSON.parse(stdout.trim())
	} catch {
		// Output wasn't valid JSON - wrap the raw text
		return { topic, summary: stdout.trim() }
	}
}

/** Format results into a markdown summary. */
function formatMarkdown(
	results: Array<Last30DaysResult | null>,
	updatedAt: string,
): string {
	const lines: string[] = [
		'# Community Intelligence',
		'',
		`Auto-generated by \`refresh-cache.ts\` on ${updatedAt}.`,
		'Refreshed every 30 days from `@side-quest/last-30-days` research.',
		'',
	]

	for (const result of results) {
		if (!result) continue

		lines.push(`## ${result.topic}`, '')

		if (result.summary) {
			lines.push(result.summary, '')
		}

		if (result.findings && result.findings.length > 0) {
			lines.push('### Key Findings', '')
			for (const finding of result.findings) {
				lines.push(`- ${finding}`)
			}
			lines.push('')
		}

		if (result.sources && result.sources.length > 0) {
			lines.push('### Sources', '')
			for (const source of result.sources) {
				lines.push(`- [${source.title}](${source.url})`)
			}
			lines.push('')
		}
	}

	return lines.join('\n')
}

async function main() {
	let cacheDir: string
	try {
		cacheDir = getCacheDir()
	} catch {
		// No CLAUDE_PLUGIN_ROOT - nothing we can do
		process.exit(0)
	}

	// Fast path: cache is fresh
	if (isCacheFresh(cacheDir)) {
		process.exit(0)
	}

	// Run all topic queries in parallel
	const results = await Promise.all(TOPICS.map(runQuery))

	// Only update if at least one query succeeded
	const hasResults = results.some((r) => r !== null)
	if (!hasResults) {
		console.error(
			JSON.stringify({
				tool: 'refresh-cache',
				status: 'warn',
				message: 'All queries failed, keeping existing cache',
			}),
		)
		process.exit(0)
	}

	const now = new Date()
	const nextUpdate = new Date(
		now.getTime() + REFRESH_INTERVAL_DAYS * 24 * 60 * 60 * 1000,
	)
	const updatedAt = now.toISOString()

	// Write community-intel.md
	const markdown = formatMarkdown(results, updatedAt)
	await Bun.write(join(cacheDir, 'community-intel.md'), markdown)

	// Write last-updated.json
	const metadata: CacheMetadata = {
		last_updated: updatedAt,
		topics_researched: TOPICS,
		next_update_after: nextUpdate.toISOString(),
	}
	await Bun.write(
		join(cacheDir, 'last-updated.json'),
		JSON.stringify(metadata, null, '\t') + '\n',
	)

	process.exit(0)
}

main().catch((err) => {
	console.error(
		JSON.stringify({
			tool: 'refresh-cache',
			status: 'fatal',
			message: String(err),
		}),
	)
	process.exit(0)
})
