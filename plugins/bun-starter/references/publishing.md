# Publishing

## Changesets Flow

The template uses [Changesets](https://github.com/changesets/changesets) for version management and npm publishing.

### Lifecycle

```
1. Developer creates changeset:  bun version:gen (or auto-generated by CI)
2. PR merged to main
3. publish.yml runs Changesets action:
   a. If pending changesets exist: opens "Version Packages" PR
   b. If version PR merged: publishes to npm + creates GitHub release
```

### Creating a Changeset

```bash
# Interactive (human — spawns TTY prompt)
bun version:gen

# Non-interactive (agent/CI — writes file directly, no TTY needed)
bun version:gen --bump minor --summary "Added new feature X"
```

The `--bump` flag accepts `patch`, `minor`, or `major`. Both `--bump` and `--summary` are required for non-interactive mode; omit both to get the interactive CLI.

Creates a `.changeset/<random-name>.md` file:

```markdown
---
"my-package": minor
---

Added new feature X
```

### Auto-generated Changesets

`autogenerate-changeset.yml` runs on every PR. If no changeset exists, it:
1. Infers bump type from PR title (`feat` = minor, `breaking` = major, else patch)
2. Generates a changeset file
3. Commits it to the PR branch
4. Comments on the PR

## OIDC Trusted Publishing

The preferred auth method for npm. No secrets needed after initial setup.

### How It Works

1. GitHub Actions requests an OIDC token from GitHub's identity provider
2. npm verifies the token matches the package's trusted publisher config
3. Publish proceeds without `NPM_TOKEN`

### Setup

**First publish** (OIDC not yet configured):
1. Create a **granular access token** at `https://www.npmjs.com/settings/<username>/tokens/granular-access-tokens/new`
   - Scope to the package or org (e.g., `@side-quest`)
   - Grant **Read and Write** permissions
   - Check **"Bypass 2FA"** (required for CI/CD)
   - Note: write tokens expire in 90 days max (npm policy since late 2025)
2. **For scoped packages** (`@org/name`), do the first publish locally:
   ```bash
   npm publish --access public --no-provenance
   ```
   Why: npm requires the package to exist before CI tokens (granular or OIDC) can publish to it. A brand new scoped package returns E404 until the first publish registers it.
   Note: `--no-provenance` is required for local publishes — provenance attestation only works in CI (GitHub Actions OIDC). Without this flag you'll get `Automatic provenance generation not supported for provider: null`.
3. Add token as a repository secret for CI: `gh secret set NPM_TOKEN --repo <owner>/<repo>`
4. CI handles subsequent publishes via Changesets (version PR → merge → auto-publish)
5. After successful publish, configure OIDC trusted publishing (see steps below)
6. Remove `NPM_TOKEN` secret (no longer needed — OIDC handles auth)

**Configure OIDC trusted publishing** (after first publish):
1. Go to `https://www.npmjs.com/package/<package-name>/access`
2. Find the **"Trusted Publisher"** section under Publishing Access
3. Click the **GitHub Actions** button
4. Fill in the **GitHub repository** details (not npm — this tells npm which GitHub repo is authorized to publish):
   - **Organization or user**: your **GitHub** username or org (e.g., `nathanvale`)
   - **Repository**: the **GitHub** repo name (e.g., `side-quest-core` — not the npm package name)
   - **Workflow filename**: `publish.yml`
   **IMPORTANT — exact field values:**
   - **Organization or user**: Your GitHub username only (e.g., `nathanvale`), NOT `nathanvale/repo-name`
   - **Repository**: Repo name only (e.g., `side-quest-runners`), NOT the full path or npm package name
   - **Workflow filename**: `publish.yml` (just the filename, not the full path)
5. Click **"Set up connection"**
6. Optionally enable **"Require two-factor authentication and disallow tokens (recommended)"**

**Key URLs:**
- Token list: `https://www.npmjs.com/settings/~/tokens`
- Create granular token: `https://www.npmjs.com/settings/<username>/tokens/granular-access-tokens/new`
- Package access (OIDC/Trusted Publisher): `https://www.npmjs.com/package/<package-name>/access`

**Requirements:**
- npm 11.6+ (provided by Node 24 setup in CI)
- `id-token: write` permission in workflow
- `publishConfig.provenance: true` in package.json

**npm token policy (as of Dec 2025):**
- Classic tokens have been permanently revoked — only granular tokens work
- Write-enabled granular tokens: 90-day max expiry, 2FA enforced by default
- Read-only tokens: up to 1-year expiry
- Use "Bypass 2FA" option for CI/CD workflows

### Fallback to NPM_TOKEN

If OIDC is not configured, `changesets-publish.sh` falls back to `NPM_TOKEN`.

**Critical:** The script writes the auth token to `NPM_CONFIG_USERCONFIG` (if set) rather than `~/.npmrc`. This is because `setup-node` with `registry-url` creates a temp `.npmrc` at `/home/runner/work/_temp/.npmrc` and sets `NPM_CONFIG_USERCONFIG` to point to it. npm reads `NPM_CONFIG_USERCONFIG` first, so writing to `~/.npmrc` has no effect — npm never sees the token.

```bash
# Correct: write to wherever npm is actually reading from
NPMRC="${NPM_CONFIG_USERCONFIG:-$HOME/.npmrc}"
echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > "$NPMRC"
```

## Pre-release Channels

### Enter Pre-release Mode

```bash
bun run pre:enter:beta    # Enter beta channel
bun run pre:enter:rc      # Enter RC channel
bun run pre:enter:next    # Enter next channel
```

Or via `pre-mode.yml` workflow dispatch.

### Publish Pre-release

```bash
bun run version:pre       # Version packages in pre-mode
bun run publish:pre       # Publish with --provenance
```

### Exit Pre-release Mode

```bash
bun run pre:exit          # Exit pre-release mode
```

### Snapshot/Canary Releases

```bash
bun run release:snapshot:canary   # Publish canary snapshot (no version bump)
```

## Package Hygiene

Before publishing, verify package quality:

```bash
bun run build             # Build output
bun run hygiene           # publint + are-the-types-wrong
bun run pack:dry          # Inspect tarball contents
```

### publishConfig

```json
{
  "publishConfig": {
    "access": "public",
    "provenance": true
  }
}
```

- `access: "public"` — Required for scoped packages
- `provenance: true` — Generates SLSA provenance attestation

## Claude Desktop Extension (.mcpb)

If your package includes an MCP server, you can distribute it as a Desktop Extension — a `.mcpb` bundle that users double-click to install in Claude Desktop.

### Setup

1. **Create `manifest.json`** in the repo root:

```json
{
  "manifest_version": "0.2",
  "name": "@scope/my-package",
  "version": "0.1.0",
  "description": "What the MCP server does",
  "author": {
    "name": "Your Name",
    "url": "https://github.com/username"
  },
  "server": {
    "type": "node",
    "entry_point": "./dist/mcp/index.js",
    "mcp_config": {
      "command": "node",
      "args": ["${__dirname}/dist/mcp/index.js"],
      "env": {
        "API_KEY": "${user_config.api_key}"
      }
    }
  },
  "user_config": {
    "api_key": {
      "type": "string",
      "title": "API Key",
      "description": "Your API key. Get one at https://example.com",
      "sensitive": true,
      "required": true
    }
  },
  "license": "MIT"
}
```

Key fields:
- `server.entry_point` — path to the compiled MCP server entry (must work with Node.js)
- `server.mcp_config.env` — env vars passed to the server, referencing `${user_config.*}`
- `user_config` — declares fields the user must provide on install. `sensitive: true` stores values in the OS keychain

2. **Create a pack script** (`scripts/pack-desktop-extension.sh`):

```bash
#!/usr/bin/env bash
set -euo pipefail

STAGE_DIR=".mcpb-stage"
OUTPUT="my-package.mcpb"

# Sync manifest version from package.json
VERSION=$(node -p "require('./package.json').version")
node -e "
  const fs = require('fs');
  const m = JSON.parse(fs.readFileSync('manifest.json', 'utf8'));
  m.version = '${VERSION}';
  fs.writeFileSync('manifest.json', JSON.stringify(m, null, '\t') + '\n');
"

bun run build

rm -rf "$STAGE_DIR"
mkdir -p "$STAGE_DIR"
cp manifest.json package.json "$STAGE_DIR/"
cp -r dist "$STAGE_DIR/"

cd "$STAGE_DIR"
npm install --omit=dev --ignore-scripts 2>&1 | tail -1
cd ..

rm -f "$OUTPUT"
npx @anthropic-ai/mcpb pack "$STAGE_DIR" "$OUTPUT"
rm -rf "$STAGE_DIR"
```

3. **Add to `.gitignore`:**

```
.mcpb-stage/
*.mcpb
```

4. **Add script to `package.json`:**

```json
{
  "scripts": {
    "pack:desktop": "bash scripts/pack-desktop-extension.sh"
  }
}
```

5. **Auto-attach to GitHub Releases** — add to `publish.yml` after the release creation step:

```yaml
- name: Attach Desktop Extension to release
  if: steps.intent.outputs.value == 'auto' && steps.changesets.outputs.published == 'true'
  run: |
    VERSION=$(node -p "require('./package.json').version")
    TAG="v${VERSION}"
    bun run pack:desktop
    gh release upload "${TAG}" my-package.mcpb --clobber
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Validation

```bash
npx @anthropic-ai/mcpb validate manifest.json   # Validate manifest schema
bun run pack:desktop                              # Build bundle
npx @anthropic-ai/mcpb info my-package.mcpb      # Inspect bundle
```

### Key considerations

- The MCP server must run under **Node.js** (not Bun) — Desktop Extensions use `node` as the runtime
- The pack script stages only `dist/`, `package.json`, `manifest.json`, and production `node_modules` — keeping the bundle small
- The version sync step ensures `manifest.json` stays in sync with `package.json` across releases
- Unsigned extensions show as "Disabled" by default — users must enable them in Claude Desktop settings

## Alternative: npm-publish-tool v2.0.0

[`npm-publish-tool`](https://github.com/nicolo-ribaudo/npm-publish-tool) v2.0.0 is an OIDC-aware alternative to `changeset publish`. It provides:
- Built-in OIDC support without npm version requirements
- Simpler CI configuration
- Automatic provenance attestation

Can be used as a drop-in replacement for the publish step if Changesets' publish command causes issues.

## Troubleshooting

### "npm ERR! 403 Forbidden" on first publish

- Scoped packages require `publishConfig.access: "public"` (already configured)
- Ensure `NPM_TOKEN` secret is set for first publish
- Token must be a **granular access token** with Read and Write permissions
- Create at: `https://www.npmjs.com/settings/<username>/tokens/granular-access-tokens/new`
- Classic tokens no longer work (revoked Dec 2025)

### "E404 Not Found" on first publish with OIDC

- OIDC trusted publishing requires the package to **already exist on npm**
- First publish must use `NPM_TOKEN` — OIDC cannot work until the package is registered
- After first publish, configure OIDC at `https://www.npmjs.com/package/<package-name>/access`

### "Access token expired or revoked"

- Classic npm tokens were permanently revoked in Dec 2025
- Create a new **granular access token** at `https://www.npmjs.com/settings/<username>/tokens/granular-access-tokens/new`
- Write tokens now expire in 90 days max — set a calendar reminder to rotate

### OIDC publish fails with "No matching package found"

- OIDC trusted publisher must be configured AFTER the first manual publish
- The package must already exist on npm

### Version PR not appearing

- Check `publish.yml` ran successfully after push to main
- Verify changeset files exist in `.changeset/` (not just README.md)
- The Changesets action only opens a PR when there are pending changesets

### Pre-release versions leaking to stable

- Ensure `pre.json` exists in `.changeset/` when in pre-mode
- Use `bun run pre:exit` before publishing stable releases

### Stable publish produces empty package (no dist/)

- `changesets-publish.sh` must run `bun run build` before `bun run release`
- Without this, `changeset publish` ships whatever is in `dist/` (often nothing)
- **Fixed in template** — ensure your `changesets-publish.sh` includes the build step

### GitHub release creation fails on workflow re-run

- `git tag` and `gh release create` are not idempotent — they fail if the tag/release already exists
- **Fix:** Guard both with existence checks (`git rev-parse` for tags, `gh release view` for releases)
- The pre-release path already had the tag check; stable path and `release.yml` were missing it
- **Fixed in template** — ensure your `publish.yml` and `release.yml` use the idempotent pattern

### NPM_TOKEN set but publish still fails with ENEEDAUTH or E404

- `setup-node` with `registry-url` sets `NPM_CONFIG_USERCONFIG=/home/runner/work/_temp/.npmrc`
- This temp `.npmrc` contains `${NODE_AUTH_TOKEN}` (a placeholder that resolves to nothing useful)
- npm reads `NPM_CONFIG_USERCONFIG` first, completely ignoring `~/.npmrc`
- So even though `changesets-publish.sh` writes the real token to `~/.npmrc`, npm never sees it
- **Fix:** Write auth to `${NPM_CONFIG_USERCONFIG}` instead of `~/.npmrc`:
  ```bash
  NPMRC="${NPM_CONFIG_USERCONFIG:-$HOME/.npmrc}"
  echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > "$NPMRC"
  ```
- **Fixed in template** — ensure your `changesets-publish.sh` uses `NPM_CONFIG_USERCONFIG`
- Symptoms: `npm notice Access token expired or revoked` followed by E404 or ENEEDAUTH, even with a valid `NPM_TOKEN` secret

### npm bin entry `./` prefix gotcha

- When using `"bin": { "my-cli": "./dist/cli.js" }` the `./` prefix is required
- Without `./`, npm may fail to resolve the binary on some platforms
- `publint` does not currently flag this — it's an undocumented footgun
- Always use `"./dist/cli.js"` not `"dist/cli.js"` in bin entries
